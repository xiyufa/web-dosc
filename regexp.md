# 正则表达式

## 一、字符匹配

#### 1.两种匹配模式

- 1.1横向模糊匹配

横向模糊指的是，一个正则可匹配的字符长度不是固定的，可以是很多种情况的,实现的方法时是使用量词。譬如`{m,n}`,表示连续出现最少m次，最多n次。

```javascript
const reg = /ab{2,5}c/g
const str = 'abc abbc abbbc abbbbc abbbbbc abbbbbbbc'

console.log(set.march(reg)) // ['abbc', 'abbbc', 'addddc', 'abbbbbc'] 
```

> 注意：案例中正则`/ab{2,5}c/g`,后面多了个`g`，它是正则的一个修饰符。表示全局匹配，既在目标字符串中按顺序找到满足匹配模式的所有子串，强调的是`所有`，而不是`第一个`。g是单词global的首字母。

- 1.2纵向模糊匹配

纵向模糊指的是，一个正则匹配的字符串，具体到某一位时，它可以不是确定的字符，恶意有多种可能。譬如`[abc]`，表示该字符可以是字符“a”、“b”、“c”中的任意一个。

```javascript
const reg = /a[123]b/g
const str = 'a0b a1b a2b a3b a4b a5b'

console.log(str.march(reg)) // ['a1b', 'a2b', 'a3b']
```

#### 2. 字符组

- 2.1 范围表示法

如果字符组里的字符特别多，可以使用范围表示法。

譬如：`[123456abcdefGHIJKLM]`，可以写成`[1-6a-fG-M]`。用连字符`-`来省略和简写。

因为连字符有特殊用途，那么要匹配`"a"`,`"-"`,`"z"`这三着中的任意一个，不能写成`[a-z]`，因为其表示小写字符中的任意一个字符。

可以写成如下方式：`[-az]`或`[az-]`或`[a\-z]`。即要么放在开头，要么放在结尾，要么转义。总之不能让引擎认为是范围表示法就行了。

- 2.2 排除字符组

纵向模式匹配，还有一种情形就是，某位字符可以是任何东西，就是不能是"a"，"b"，"c"。

此时就是排除字符组（反义字符组）的概念。譬如`[^abc]`，表示一个除"a"，"b"，"c"之外的任意一个字符。字符的第一位放`^`(脱字符)，表示求反的概念。

当然，也有相应的范围表示法。

- 2.3 常见的简写形式

系统自带的简写形式

`\d`就是`[0-9]`。表示是一位数字

`\D`就是`[^0-9]`。表示除数字以外的任意字符。

`\w`就是`[0-9a-zA-Z_]`。表示数字、大小写字母和下划线。

`\W`是`[^0-9a-zA-Z_]`。非单词字符。

`\s`是`[ \t\v\n\r\f]`。表示空白符，包括空格、水平制表符、垂直制表符、换行符、回车符、换页符。

`\S`是`[^ \t\v\n\r\f]`。表示非空白符。

`.`就是`[^ \n\r\u2028\u2029]`。通配符，表示几乎任意字符。换行符、回车符、行分隔符和段分隔符除外。

> 匹配任意字符： `[\d\D]`、`[\s\S]`、`[\w\W]`、`[^]`。

#### 3. 量词

- 3.1 简写形式

`{m,}`表示至少出现m次。

`{m}`等价于`{m,m}`，表示出现m次。

`?`等价于`{0,1}`，表示出现或者不出现。

`+`等价于`{1,}`，表示出现至少一次。

`*`等价于`{0,}`，表示出现n次，有可能不出现。

- 3.2 贪婪匹配和惰性匹配

```javascript
let reg = /\d{2,5}/g
let str = '123 1234 12345 123456'
console.log(str.match(reg)) // ['123', '1234', '12345', '12345']
```

其中正则`/\d{2,5}/`,表示数字连续出现2到5次。